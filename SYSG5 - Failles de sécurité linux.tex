\documentclass[a4paper, 12pt]{article}




\makeatletter
\title{SYSG5 : Exploitation de failles de sécurité LINUX}
\let\Title\@title
\author{Antoine Ghigny - 56359}          \let\Author\@author
\date{29/10/2022}           \let\Date\@date
\makeatother

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{titling}

\usepackage[a4paper,
            bindingoffset=0.2in,
            left=1in,
            right=1in,
            top=1in,
            bottom=1in,
            footskip=.25in]{geometry}
            
\usepackage{blindtext}

\usepackage{graphicx,color, caption2}
\usepackage{epsfig}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}
\usepackage{makeidx}

% Valeurs par défaut le lstset
\lstset{language={},%C,Assembleur, TeX, tcl, basic, cobol, fortran, logo, make, pascal, perl, prolog, {}
	literate={â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
		 {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
		 {à}{{\`a}}1 {é}{{\'e}}1 {è}{{\`e}}1 {ù}{{\`u}}1 
		 {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
		 {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
		 {À}{{\`A}}1 {É}{{\'E}}1 {È}{{\`E}}1 {Ù}{{\`U}}1,
	commentstyle=\scriptsize\ttfamily\slshape, % style des commentaires
	basicstyle=\scriptsize\ttfamily, % style par défaut
	keywordstyle=\scriptsize\rmfamily\bfseries,% style des mots-clés
	backgroundcolor=\color[rgb]{.95,.95,.95}, % couleur de fond : gris clair
	framerule=0.5pt,% Taille des bords
	frame=trbl,% Style du cadre
	frameround=tttt, % Bords arrondis 
	tabsize=3, % Taille des tabulations
%	extendedchars=\true, % Incompatible avec utf8 et literate
	inputencoding=utf8,
	showspaces=false, % Ne montre pas les espaces 
	showstringspaces=false, % Ne montre pas les espaces entre ''
	xrightmargin=-1cm, % Retrait gauche 
	xleftmargin=-1cm, % Retrait droit
	escapechar=°}  % Caractère d'échappement, permet des commandes latex dans la source

\begin{document}
\maketitle 

   \tableofcontents

   \section{Dépassement de mémoire : Pwnkit}   		
		\subsection{Origine de la faille}   
   		\begin{flushleft}
			\noindent 	Polkit est bibliothèque sur laquelle a été découvert cette vulnérabilité. Il a été créé à la base pour permettre aux dévelopeurs de réaliser des actions qui nécessitaient des privilèges élevés sur le système. On peut le comparer à sudo qui fait essentiellement la même chose côté utilisateur.
   			\item Cette faille va s'intéresser à l'utilisation de la commande \textbf{pkexec} qui fait partie de la bibliothèque polkit. L'appel système pkexec est apparu en 2009 et inclus dans pratiquement toutes les distributions linux actuelles.
   			\item Cette faille de sécurité est présente depuis 12 ans et récemment mise en évidence par l'équipe de recherche Qualys en février 2022. \cite{qualys}
   			\item Cette faille permet en n’importe quel attaquant qui possède un compte sur un système linux de devenir le root du système sans quasiment aucun effort.
   		\end{flushleft}
   		\subsection{Comment cela fonctionne ? (à modifier) }
   		\begin{flushleft}
   			\noindent \textbf{pkexec} est une commande commme les autres, on peut lui passer des arguments
   			\item Mais il y a un gros problème dans la façon dont il va être implémentée, si l'argument argc est à la valeur NULL, le fonctionnement de pkexec va être déréglé. 
   			\item En manipulant des variables d'environnements et en créant des dossiers qui portent le même nom que ce qu'on va inscrire dans les variables d'environnement. Il est possible de charger un bout de code à un endroit contrôlé par l'attaquant. 
   		\end{flushleft}
   		
   		\subsection{Détails tecniques sur la faille (à compléter) }
   		\begin{flushleft}
   			\noindent Le début de la fonction main() de pkexec traite les arguments de ligne de commande (lignes 534-568), et recherche le programme à exécuter, si son chemin n’est pas absolu, dans les répertoires de la variable d’environnement PATH (lignes 610-640) :
   			\begin{lstlisting}
435 	main (int argc, char *argv[])
436 	{
...
534 		for (n = 1; n < (guint) argc; n++)
535     	{
...
568     	}
...
610   		path = g_strdup (argv[n]);
...
629   		if (path[0] != '/')
630     	{
...
632     		s = g_find_program_in_path (path);
...
639       		argv[n] = path = s;
640     }
        	\end{lstlisting}
        	\item Malheureusement, si le nombre d’arguments de ligne de commande argc est égal à 0, ce qui signifie que si la liste d’arguments argv que nous passons à execve() est vide, c’est-à-dire {NULL}, alors argv[0] est NULL. Il s’agit du terminateur de la liste d’arguments. Donc:
        	\begin{itemize}
        		\item à la ligne 534, l’entier n est définitivement défini sur 1;
        		\item À la ligne 610, le chemin du pointeur est lu hors limites à partir de argv[1] ;
        		\item À la ligne 639, le pointeur S est écrit hors limites dans argv[1].
        		\item À la ligne 610, le chemin du programme à exécuter est lu hors limites à partir de argv[1] (c’est-à-dire envp[0]), et pointe vers « value »;
        		\item ...
        	\end{itemize}
        	
   		\end{flushleft}
   		\subsection{Comment savoir si la faille est exploitable sur le système ?}
   		La \textbf{version de pkexec} doit être inférieure à \textbf{0.105}. Il est possible de vérifier cela sur la machine de la victime en tapant la commande ci dessous : 
\begin{lstlisting}
pkexec --version
\end{lstlisting}

   		
   		\newpage
   		\subsection{Démonstration}
			\subsubsection{Le code C (à modifier) }   		
			
			\lstinputlisting{Code/exploit.c}  
				
			\subsubsection{Script qui permet d'exécuter la faille}   	
			\lstinputlisting{Code/Demo}
		\subsection{Comment a été corrigée cette faille (à modifier)}
		Cette faille a été corrigée dans la version 0.105 de pkexec.

   \section{Modifier le mot de passe administrateur sans le connaître}
        \subsection{grub}
        \begin{enumerate}
        	\item \textbf{Eteindre le pc} et après avoir rallumé l'ordinateur, ouvrir les options avancées et \textbf{ouvrir Grub}. Il s'agit d'un programme d'ammorçage du chargement d'un système d'exploitation. C'est ce qui fait le lien entre le bios et le système d'exploitation. Avant que le système ne soit chargé ou lancé.
        	\item Entrer en mode édition via la touche 'E'. Dans le menu GRUB, recherchez la ligne du noyau commençant par linux /boot/ et ajoutez cette ligne
        	\begin{lstlisting}
        		init=/bin/bash
        	\end{lstlisting}
        	\item Sauvegardez les changements via en appuyant sur \textbf{CTRL + X} et rebooter en mode single-user mode.
        	\item Dans le terminal, indiquez la ligne
        	\begin{lstlisting}
        		mount -o remount,rw /
        	\end{lstlisting}
        	\item Une fois cela fait, vous pouvez modifier le password administrateur via cette la commande ci-dessous, vous n'aurez qu'à entrer le nouveau mot de passe et une autre fois pour confirmer. Il suffit de redémarrer le système et le password administrateur aura été modifié. 
        	\begin{lstlisting}
        		passwd root
        	\end{lstlisting}
        \end{enumerate}
   \section{Bombe zip}
   		\subsection{Qu'est-ce qu'une zip bomb ?}
         Une zip bomb est un fichier compressé de quelques MO qui contient énormément de données présente sous formes d'octets, ce qui va amener à saturer le disque dur. Le système va manquer de mémoire et se bloquer dans le processus.
		\subsection{Comment faire une zip bomb ?}
		\begin{flushleft}
			\noindent Entrez cette commande dans le terminal. 
			\item Cela compresse 100 To de données dans un fichier d’environ 14,9 Mo. Ainsi, lorsque quelqu’un essaie de l’extraire, il devrait s’étendre à plus de 1300000x sa taille et leur disque dur devrait être rempli de caractères nuls!
		
			\begin{lstlisting}
        		dd if=/dev/zero bs=10G count=10000 | bzip2 -c > zipBomb.bz2
        	\end{lstlisting}
        	\item Il suffit alors d'extraire le fichier via la commande suivante : 
        	\begin{lstlisting}
        		bzip2 -d zipBomb.bz2
        	\end{lstlisting}
        \end{flushleft}
	\bibliography{bibliozq}
	\bibliographystyle{plain}
\end{document}
