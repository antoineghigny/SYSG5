\documentclass[a4paper, 12pt]{article}


\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}

\makeatletter
\title{SYSG5 : Exploitation de failles de sécurité LINUX}
\let\Title\@title
\author{Antoine Ghigny - 56359 - E12}          \let\Author\@author
\date{19/11/2022}           \let\Date\@date
\makeatother

\usepackage{titling}

\usepackage[a4paper,
            bindingoffset=0.2in,
            left=1in,
            right=1in,
            top=1in,
            bottom=1in,
            footskip=.25in]{geometry}
            
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{graphicx,color, caption}
\usepackage{epsfig}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}
\usepackage{makeidx}
\usepackage{verbatim}

% Valeurs par défaut le lstset
\lstset{language={},%C,Assembleur, TeX, tcl, basic, cobol, fortran, logo, make, pascal, perl, prolog, {}
	literate={â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
		 {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
		 {à}{{\`a}}1 {é}{{\'e}}1 {è}{{\`e}}1 {ù}{{\`u}}1 
		 {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
		 {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
		 {À}{{\`A}}1 {É}{{\'E}}1 {È}{{\`E}}1 {Ù}{{\`U}}1,
	commentstyle=\scriptsize\ttfamily\slshape, % style des commentaires
	basicstyle=\scriptsize\ttfamily, % style par défaut
	keywordstyle=\scriptsize\rmfamily\bfseries,% style des mots-clés
	backgroundcolor=\color[rgb]{.95,.95,.95}, % couleur de fond : gris clair
	framerule=0.5pt,% Taille des bords
	frame=trbl,% Style du cadre
	frameround=tttt, % Bords arrondis 
	tabsize=3, % Taille des tabulations
%	extendedchars=\true, % Incompatible avec utf8 et literate
	inputencoding=utf8,
	showspaces=false, % Ne montre pas les espaces 
	showstringspaces=false, % Ne montre pas les espaces entre ''
	escapechar=°}  % Caractère d'échappement, permet des commandes latex dans la source

\begin{document}
\maketitle 
   \newpage
   \tableofcontents

	\newpage
   \section{Introduction (à modifier)}
   \begin{flushleft}
       \noindent Dans ce rapport, je vais détailler plusieurs failles découvertes autour de mes recherches. L'origine de ces failles, la raison de leurs existence. Le moyen de les exploiter mais également comment s'en protéger.
       \item Je vais tout d'abord parler d'une faille permettant à n'importe quel utilisateur du système d'augmenter ses privilèges à ceux de root. Une faille présente depuis 12 ans et corrigée début 2022. 
       \item Je vais ensuite expliquer comment modifier le mot de passe root depuis le grub sans le connaître. Pourquoi ce n'est pas sécurisé et commment s'en protéger. 
       \item Je vais dans le cadre de ce cours du système introduire des concepts (à modifier)
   \end{flushleft}

   \section{Préparation}
    \subsection{Installation de l'image disque}
    \begin{flushleft}
       \noindent Afin de pouvoir tester certaines failles qui ont été corrigées via des mises à jour. J'ai réalisé un l'environnement suivant. 
       \item OS : 
       \begin{itemize}
           \item  Debian 10
           \item Image: \href{https://cdimage.debian.org/mirror/cdimage/archive/10.7.0/amd64/iso-dvd/debian-10.7.0-amd64-DVD-1.iso}{debian-10.7.0-amd64-DVD-1.iso } \cite{CVE2021350:online}
           \item System info: Linux debian 4.19.0-14-amd64 \#1
       \end{itemize}
       \item SUDO : 
       \begin{itemize}
           \item Package version: 1.8.27-1+deb10u2
           \item Checksum (sha256): ca4a94e0a49f59295df5522d896022444cbbafdec4d94326c1a7f333fd030038
           \item Source code: \href{https://www.sudo.ws/dist/sudo-1.8.27.tar.gz}{sudo-1.8.27.tar.gz} \cite{CVE2021350:online}
       \end{itemize}

       \subsection{Vérification de la copie}
       \item Il est important de vérifier l’intégrité et l’authenticité de votre image ISO.
       \item Le test d’intégrité confirme que votre image ISO a été proprement téléchargée et qu’elle est une copie exacte du fichier présent sur le miroir de téléchargement. Une erreur pendant le téléchargement peut corrompre l’image et engendrer des problèmes aléatoires pendant l’installation.
       \item Pour vérifier l’intégrité de votre image ISO, générez sa somme de hachage SHA256 et comparez la à la somme qu'il devrait avoir : \textbf{ca4a94e0a49f59295df5522d896022444cbbafdec4d94326c1a7f333fd030038}
        \begin{lstlisting}
sha256sum -b debian-10.7.0-amd64-DVD-1.iso
        \end{lstlisting}
        \item Sil les sommes correspondent, votre image ISO a été proprement téléchargée. Sinon téléchargez la à nouveau. 
       
       \subsection{Création d'un stick USB bootable}
       \item Munissez-vous d'une clé USB, branchez-là sur un ordinateur.
       \item Placez le stick USB, attendez une seconde et tapez la commande \textbf{dmesg}
       \item Les dernières lignes affichées de cette commande vous donnent le nom du pilote associé au stick (sdb,
sdc, sdd, ...), par exemple sdb.
        \item Une fois l'image disque installée et votre nom du pilote associé au stick usb récupéré. 
        \item Entrez la commande suivante : 
        \begin{itemize}
            \item \textbf{Downloads/debian-10.7.0-amd64-DVD-1.iso} correspond au chemin où se situe l'image disque téléchargée plus tôt. 
            \item \textbf{/dev/sdb} correspond quant à lui au nom du pilote asocié à votre disque. : 
        \end{itemize}
        \begin{lstlisting}
sudo dd bs=4M if=Downloads/debian-10.7.0-amd64-DVD-1.iso of=/dev/sdb conv=fdatasync
        \end{lstlisting}
        

       \subsection{Configuration du réseau}
       \item Pour configurer le réseau avec celui de l'école j'ai encodé les éléments suivant
       \begin{itemize}
           \item IP : 10.0.255.20
           \item Gateway : 10.0.255.115
           \item Masque de sous réseau : 255.255.255.0
           \item DNS : 195.238.2.21 195.238.2.21 8.8.8.8
       \end{itemize}
       \subsection{Configuration des partitions}
       \item Les partitions à paramètrer ont été les suivantes : 
       \begin{itemize}
           \item 1 : Changer la partition de fat16 à EFI
           \item 2 : biosgrub
           \item 5 : swap
           \item 6 : 15 GB : / 
           \item 7 : 10 GB : /home
           \item 8 : 10GB : /usr 
       \end{itemize}
       \subsection{Configuration de l'environnement de travail}
       \item Et enfin j'ai ajouté l'utilisateur au groupe sudo comme c'est généralement le cas sur un environnement linux.
       \begin{lstlisting}
su -
addgroup user sudo
sudo apt-get update
       \end{lstlisting}
       \item Afin de pouvoir installer des packets, il faudra update pour télécharger les informations des packages des sources configurées.
       \item Pour cela, accédez en écriture au fichier \textbf{/etc/apt/sources.list}
       \item Mettez en commentaire la ligne concernant le cdrom installé [Debian GNU/Linux...]
       \item Ajoutez au fichier les 2 lignes suivantes : 
       \begin{lstlisting}
deb http://deb.debian.org/ buster-updates main contrib
deb-src http://ftp.debian.org/debian/ buster main contrib
       \end{lstlisting}
    \item Enfin, sauvez le fichier et mettez téléchargez les packets via la commande suivante
    \begin{lstlisting}
sudo apt-get update
    \end{lstlisting}
    \item Votre environnement de développement est maintenant prêt.
   \end{flushleft}

   \section{Privilege Escalation : Pwnkit}   		
		\subsection{Origine de la faille}   
   		\begin{flushleft}
   			\noindent Cette faille va s'intéresser à l'utilisation de la commande \textbf{pkexec} qui fait partie de la bibliothèque polkit. L'appel système pkexec est apparu en 2009 et inclus dans pratiquement toutes les distributions linux actuelles.
   			\item Cette faille de sécurité est présente depuis 12 ans et récemment mise en évidence par l'équipe de recherche Qualys en février 2022. \cite{qualys}
   			\item Cette faille permet à n’importe quel attaquant qui possède un compte sur un système linux de devenir le root du système.
            \subsection{A quoi sert la bibliothèque Polkit et en particulier l'appel système pkexec ? }
            \begin{flushleft}
                \noindent Polkit (anciennement PolicyKit) est une bibliothèque logicielle libre permettant aux applications s'exécutant avec des droits restreints d'interagir avec des services privilégiés du système. À la différence d'autres méthodes permettant une élévation des privilèges comme sudo, le processus ne se voit pas attribuer les droits superutilisateur, ce qui permet un contrôle fin au niveau du système de ce que peuvent faire ou non les utilisateurs. \cite{policyki47:online}
                \item C'est un logiciel moderne actuellement privilégié par les développeurs d'environnements graphiques grâce à la sécurité qu'il fournit, en effet il fonctionne selon le principe suivant : 
                \item Un programme (démon) s'exécute en arrière-plan (sans fenêtre), et dispose des droits root.
                \item Les applications sont invitées à lui demander les droits nécessaires pour effectuer des opérations spécifiques.
                \item PolKit saura quoi répondre en fonction des "policy" paramétrées (des configurations qui définissent qui peut faire quoi, et quel logiciel a besoin de quels privilèges).
                \item Polkit est intégré aux distributions Ubuntu (depuis la version 8.04), Fedora (depuis la version 8), Mandriva (depuis la version 2008.1) et OpenSUSE (depuis la version 10.3).
                \subsubsection{Utilisation des "policy"}
                \begin{flushleft}
                    \noindent Pour gérer les règles il faut donc éditer les fichiers de configuration avec les droits d'administration. La configuration se fait avec des règles et des actions :
                    \begin{itemize}
                        \item Les Actions sont définies dans des fichiers XML .policy situés dans \textbf{/usr/share/polkit-1/actions} 
                        \item Les règles d'autorisation sont définies dans les fichiers .rules JavaScript. On les trouve à deux endroits : \cite{PartVMan11:online}
                        \begin{itemize}
                            \item \textbf{/usr/share/polkit-1/rules.d} pour les paquets tiers peuvent utiliser (bien que peu, voire aucun, ne le fasse)
                            \item \textbf{/etc/polkit-1/rules.d} pour la configuration locale.
                        \end{itemize}
                    \end{itemize}
                \end{flushleft}
                \subsubsection{Utilisation classique de l'appel système pkexec (à modifier)}
                \subsubsection{Quelle est la différence entre pkexec et sudo ?}
                \begin{flushleft}
                    \noindent Dans le concept, ils font la même chose, permettant à un utilisateur d'exécuter un autre programme en tant qu'autre utilisateur
                    \item Sudo et son frère aîné su, vous donnent un contrôle total sur tout.
                    \item Pkexec fait partie d'un système d'outils plus vaste appelé Polkit. Cela prend un peu de temps pour le configurer, mais une fois sur place, il donne un contrôle beaucoup plus fin.
                    \item C'est une bonne idée pour s'isoler de certains dangers et avoir l'accès complet à tout dans le système.
                \end{flushleft}
            
            \end{flushleft}
   		\end{flushleft}
   		\subsection{Comment la faille fonctionne-elle ? (à modifier) }
   		\begin{flushleft}
   			\noindent \textbf{pkexec} est une commande comme les autres, on peut lui passer des arguments
   			\item Mais il y a un gros problème dans la façon dont il va être implémentée, si l'argument argc est à la valeur NULL, le fonctionnement de pkexec va être déréglé. 
   			\item En manipulant des variables d'environnements et en créant des dossiers qui portent le même nom que ce qu'on va inscrire dans les variables d'environnement. Il est possible de charger un bout de code à un endroit contrôlé par l'attaquant. 
   		\end{flushleft}
   		
   		\subsection{Détails techniques sur la faille (à compléter) }
   		\begin{flushleft}
   			\noindent Le début de la fonction main() de pkexec traite les arguments de ligne de commande (lignes 534-568), et recherche le programme à exécuter, si son chemin n’est pas absolu, dans les répertoires de la variable d'environnement PATH (lignes 610-640) :
   			\begin{lstlisting}
435 	main (int argc, char *argv[])
436 	{
...
534 		for (n = 1; n < (guint) argc; n++)
535     	{
...
568     	}
...
610   		path = g_strdup (argv[n]);
...
629   		if (path[0] != '/')
630     	{
...
632     		s = g_find_program_in_path (path);
...
639       		argv[n] = path = s;
640     }
        	\end{lstlisting}
        	\item Malheureusement, si le nombre d’arguments de ligne de commande argc est égal à 0, ce qui signifie que si la liste d’arguments argv que nous passons à execve() est vide, c’est-à-dire {NULL}, alors argv[0] est NULL. Il s’agit du terminateur de la liste d’arguments. Donc:
        	\begin{itemize}
        		\item à la ligne 534, l’entier n est définitivement défini sur 1;
        		\item À la ligne 610, le chemin du pointeur est lu hors limites à partir de argv[1] ;
        		\item À la ligne 639, le pointeur S est écrit hors limites dans argv[1].
        		\item À la ligne 610, le chemin du programme à exécuter est lu hors limites à partir de argv[1] (c’est-à-dire envp[0]), et pointe vers « value »;
        		\item ...
        	\end{itemize}
        	
   		\end{flushleft}
   		\subsection{Comment savoir si la faille est exploitable sur le système ?}
   		La \textbf{version de pkexec} doit être inférieure à \textbf{0.105}. Il est possible de vérifier cela sur la machine de la victime en tapant la commande ci dessous : 
\begin{lstlisting}
pkexec --version
\end{lstlisting}
   		\subsection{Démonstration}
			\subsubsection{Le code C (à modifier) } 
			\lstinputlisting{../Code/exploit.c}  
				
			\subsubsection{Script qui permet d'exécuter la faille}   	
			\lstinputlisting{../Code/Demo}
		\subsection{Comment a été corrigée cette faille (à modifier)}
		Cette faille a été corrigée dans la version 0.105 de pkexec.
            \subsection{Comment corriger cette faille si il n'est pas possible d'ugrade la version de pkexec ? (à modifier)}

   \section{Modifier le mot de passe administrateur sans le connaître}
        
        \subsection{Démonstration : GRUB}
        \begin{enumerate}
        	\item \textbf{Eteindre le pc} et après avoir rallumé l'ordinateur, ouvrir les options avancées et \textbf{ouvrir Grub}. Il s'agit d'un programme d'ammorçage du chargement d'un système d'exploitation. C'est ce qui fait le lien entre le bios et le système d'exploitation. Avant que le système ne soit chargé ou lancé.
        	\item Entrer en mode édition via la touche 'E'. Dans le menu GRUB, recherchez la ligne du noyau commençant par linux /boot/ et ajoutez cette ligne à la fin.
        	\begin{lstlisting}
init=/bin/bash
        	\end{lstlisting}
        	\item Sauvegardez les changements via en appuyant sur \textbf{CTRL + X} et rebooter en mode single-user mode.
        	\item Dans le terminal, indiquez la ligne
        	\begin{lstlisting}
mount -o remount,rw /
        	\end{lstlisting}
        	\item Une fois cela fait, vous pouvez modifier le password administrateur via cette la commande ci-dessous, vous n'aurez qu'à entrer le nouveau mot de passe et une autre fois pour confirmer. Il suffit de redémarrer le système et le password administrateur aura été modifié. 
        	\begin{lstlisting}
passwd root
        	\end{lstlisting}
        \end{enumerate}
   \subsection{Pourquoi ça fonctionne ainsi ? Pourquoi est-il si simple de changer le mot de passe administrateur ?} 
   \begin{flushleft}
       \noindent Les mots de passe sont destinés à empêcher l'accès de l'extérieur (réseau, Internet), et ils le font. Cependant, l'accès physique est un accès root.
       \item À moins que vous ne cryptiez l'intégralité de votre partition, il est toujours possible de démarrer à partir d'un disque optique ou d'un lecteur flash et d'accéder à tous vos fichiers. De cette façon, vous pouvez également modifier les fichiers qui stockent les mots de passe des utilisateurs.
       \item Donc si quelqu'un peut toucher à votre machine, il peut y entrer.
   \end{flushleft}

   \subsection{Comment protéger le grub pour ne plus que cette faille soit possible} 
   \begin{flushleft}
       \noindent Il est possible d'ajouter un mot de passe à grub.
       \item Un mot de passe sera alors requis pour modifier les entrées du menu mais pas pour démarrer les entrées de menu existantes. 
       \item Pour cela, créez un mot de passe avec la commande suivante. Vous aurez à entrer un mot de passe, confirmer et ne surtout pas oublier le mot de passe que vous avez encodé.
       \begin{lstlisting}
grub2-setpassword
       \end{lstlisting}
       \item Cette commande créera ou mettra à jour le contenu de \textbf{/boot/grub2/user.cfg} avec le mot de passe hashé. \cite{Howtopro9:online}
       
   \end{flushleft}
   \section{Bombe zip}
   		\subsection{Qu'est-ce qu'une zip bomb ?}
         Une zip bomb est un fichier compressé de quelques MO qui contient énormément de données présente sous formes d'octets, ce qui va amener à saturer le disque dur. Le système va manquer de mémoire et se bloquer dans le processus.
		\subsection{Démonstration : Comment faire une zip bomb ?}
		\begin{flushleft}
			\noindent Entrez cette commande dans le terminal. 
			\item Cela compresse 100 To de données dans un fichier d’environ 14,9 Mo. Ainsi, lorsque quelqu’un essaie de l’extraire, il devrait s’étendre à plus de 1300000x sa taille et leur disque dur devrait être rempli de caractères nuls!
		
			\begin{lstlisting}
dd if=/dev/zero bs=10G count=10000 | bzip2 -c > zipBomb.bz2
        	\end{lstlisting}
        	\item Il suffit alors d'extraire le fichier via la commande suivante : 
        	\begin{lstlisting}
bzip2 -d zipBomb.bz2
        	\end{lstlisting}
        \end{flushleft}

    \section{Conclusion}
        \nocite{*}
	\bibliography{bibliozq}
	\bibliographystyle{plain}
\end{document}
